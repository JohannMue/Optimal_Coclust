from datetime import datetime
import numpy
from coclust.coclustering import CoclustSpecMod, CoclustMod, CoclustInfo
from optimal_cocluster.bic import bic_cocluster
import warnings
from optimal_cocluster.helperfunctions import progress


def coclust_iterate(matrix,
                    modeltype,
                    n_col_clusters=None,
                    n_row_clusters=None,
                    n_clusters=None,
                    savemodel=False,
                    namestr="",
                    path="",
                    **kwargs):
    """
    Generates a range of co-clustering solutions using package Coclust.
    :param matrix: dataset to be clustered
    :param modeltype: The clustering algorithm from Coclust to be used:
    "mod": CoclustMod(), "specmod": CoclustSpecMod(), "info": CoclustInfo()
    :param n_col_clusters: number of column clusters if modeltype == "info"
    :param n_row_clusters: number of row clusters if modeltype == "info"
    :param n_clusters: number of clusters to be used if modeltype != "info"
    :param savemodel: bool, TRUE saves the resulting list of models using pickle under path
    :param namestr: optional name, used in filename when pickling
    :param path: optional path to a directory, used when pickling
    :param kwargs: kwargs to clustering functions from Cuclust
    :return: list of coclustering models
    """
    warnings.filterwarnings("ignore", category=FutureWarning)
    cluster = None
    n_iterations = n_clusters
    if modeltype == "mod":
        cluster = CoclustMod
    elif modeltype == "specmod":
        cluster = CoclustSpecMod
    elif modeltype == "info":
        cluster = CoclustInfo
        n_clusters = n_col_clusters
        n_iterations = n_col_clusters * n_row_clusters

    models = []
    now = datetime.now()
    print(now.strftime("%d%m%H:%M"), "Clustering ", n_iterations, "iterations ...")
    for c in range(n_clusters):
        if modeltype == "mod" or modeltype == "specmod":
            model = cluster(n_clusters=c + 1, **kwargs)
            model.fit(matrix)
            models.append(model)
            progress(c + 1, n_clusters)
        else:
            for r in range(n_row_clusters):
                model = cluster(n_row_clusters=c + 1, n_col_clusters=r + 1, **kwargs)
                model.fit(matrix)
                models.append(model)
                step = r + 1 + c * n_row_clusters
                progress(step, n_clusters * n_row_clusters)
    print("... completed.")

    if savemodel:
        try:
            import pickle
            with open(path + namestr + modeltype + 'Models' + str(n_col_clusters) + "-" + str(n_row_clusters),
                      'wb') as f:
                pickle.dump(models, f)
        except ModuleNotFoundError:
            pass

    return models


def max_bic_models(models,
                   matrix,
                   n_top=5):
    """
    evaluates a list of Coclust models using Bayesian Information Criterion and identifies the model with max BIC
    :param models: list of coclustering models (generated by coclust_iterate())
    :param matrix: data to be clustered
    :param n_top: number of top solutions to output
    :return: lit of two elements [0] = the best model from the provided list, [1]: the list of BIC values,
    (corresponds to the model list)
    """
    BIC_collect = []
    now = datetime.now()
    print(now.strftime("%d%m%H:%M"), "Evaluating ", len(models), "models ...")
    for step, model in enumerate(models):
        result = bic_cocluster(colpartition=model.column_labels_, rowpartition=model.row_labels_, matrix=matrix)
        BIC_collect.append(result[0])
        progress(step + 1, len(models))
    print("... completed.")
    top = (-numpy.array(BIC_collect[1])).argsort()[:n_top]
    top_models = numpy.array(models)[top]
    top_bic = numpy.array(BIC_collect)[top]
    return {
        "best_model": top_models[0],
        "best_bic": top_bic[0],
        "best_n_models": top_models,
        "best_n_bic": top_bic,
        "bic": BIC_collect}


def iterate_cluster(matrix, modeltype, **kwargs):
    """
    Unifies clustering and evalluation into one step.
    Not recommended as computation can be time consuming and stepwise execution with saving in between is preferable.
    :param matrix: the data to be clustered
    :param modeltype:The clustering algorithm from Coclust to be used:
    "mod": CoclustMod(), "specmod": CoclustSpecMod(), "info": CoclustInfo()
    :param kwargs: kwargs to coclust_iterate()
    :return: list of results from functions coclust_iterate() and max_BIC_model()
    """
    models = coclust_iterate(matrix, modeltype, kwargs)
    bic_result = max_bic_models(models, matrix)
    print(bic_result[0])
    return bic_result, models
